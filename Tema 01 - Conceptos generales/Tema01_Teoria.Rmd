---
title: "R para Ingenier√≠as y Ciencias"
author: "La Academia"
subtitle: "Tema 01 - Teor√≠a"
output:
  html_document:
    df_print: paged
---

# Conceptos generales

## Enfoque EPS: Entradas - Procedimiento - Salidas

El enfoque **Entradas - Procedimiento - Salidas (EPS)**, tambi√©n llamado **Entradas - Procedimiento - Resultados**, es una forma estructurada de programar en la que se organizan los datos y las operaciones en tres etapas principales:

1.  **Entradas:** Datos proporcionados al programa. Pueden ser valores num√©ricos, texto, archivos, sensores, etc.
2.  **Procedimiento:** Operaciones y c√°lculos que transforman las entradas en resultados. Incluye funciones, ecuaciones y algoritmos.
3.  **Salidas:** Resultados generados, que pueden mostrarse en pantalla, guardarse en archivos o enviarse a otros sistemas.

![Definici√≥n visual del enfoque EPS.](https://github.com/aisacc/Programacion-R/blob/main/_Im%C3%A1genes/Tema%2001%20-%20Conceptos%20generales/1.png?raw=true){width="500"}

El siguiente ejemplo ilustra la aplicaci√≥n de este enfoque. *No es necesario entender cada parte del ejemplo en esta etapa de aprendizaje. Todo esto ser√° cubierto en el transcurso del curso.*

### Ejemplo

Calcular el √°rea de un cilindro.

### Soluci√≥n

``` r
# Entradas
radio <- 5          # Radio del cilindro (m)
altura <- 10        # Altura del cilindro (m)

# Procedimiento
area_lateral <- 2 * pi * radio * altura             # √Årea lateral
area_total <- area_lateral + 2 * pi * radio^2       # √Årea total

# Salidas
print(paste("√Årea lateral:", area_lateral, "m¬≤"))
print(paste("√Årea total:", area_total, "m¬≤"))
```

> Haciendo una analog√≠a a la aplicaci√≥n en ingenier√≠a, este enfoque es similar a un **proceso de manufactura**:
>
> -   **Entradas:** Materias primas (materiales, energ√≠a).
> -   **Procedimiento:** Procesamiento en m√°quinas y sistemas.
> -   **Salidas:** Productos terminados y datos de control de calidad.
>
> En **R**, estructurar el c√≥digo con el **enfoque EPS** mejora la claridad, reutilizaci√≥n y facilidad de depuraci√≥n.

------------------------------------------------------------------------

## Creaci√≥n de variables

En **R**, una variable es un espacio en memoria donde se almacena un valor que puede cambiar a lo largo del programa. Se crean mediante la asignaci√≥n con los operadores `<-`, `=` o con la funci√≥n `assign()`.

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

> Imagina que **una variable en R** es como un **sensor** en un sistema de monitoreo industrial. Cada **sensor (variable)** almacena un valor en un instante dado, como la temperatura de un horno, la presi√≥n de un tanque o la velocidad de un motor. Puedes leer esos valores, actualizarlos y utilizarlos para c√°lculos dentro de un sistema de control.

### Ejemplo

Supongamos que en un sistema mec√°nico necesitamos calcular la **energ√≠a cin√©tica** de un objeto en movimiento. La f√≥rmula es:

$$
E_k = \frac{1}{2} m v^2
$$

Donde $E_k$ es la energ√≠a cin√©tica (Joules), $m$ es la masa del objeto (kg) y $v$ es la velocidad del objeto (m/s).

**Crear las variables** necesarias para determinar la energ√≠a cin√©tica del objeto en movimiento.

> [**Nota 1:**]{.underline} Por el momento no es necesario realizar las operaciones aritm√©ticas involucradas.
>
> [**Nota 2:**]{.underline} Recuerda seguir el **enfoque EPS**.

### Soluci√≥n

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

------------------------------------------------------------------------

## Nombres representativos para variables

En programaci√≥n, elegir **nombres representativos** para las variables es clave para mejorar la legibilidad y mantenibilidad del c√≥digo. En **R**, un nombre adecuado debe describir claramente el prop√≥sito de la variable dentro del contexto del problema.

A continuaci√≥n te comparto algunas recomendaciones para nombrar tus variables.

1.  **Usar nombres descriptivos.**
    -   ‚ùå `x <- 10`. Poco claro.

    -   ‚úÖ `radio_cilindro <- 10.` Claro y significativo.
2.  **Evitar abreviaturas excesivas.**
    -   ‚ùå `tmpr <- 25`. Confuso.

    -   ‚úÖ `temperatura_ambiente <- 25`. M√°s claro.
3.  **Seguir una convenci√≥n de escritura.**
    -   **Snake case:** `altura_puente <- 50`. Recomendado en R.

    -   **Camel case:** `alturaPuente <- 50`. Utilizado en otros lenguajes.

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

El programar eres t√∫, as√≠ que si√©ntete libre de seguir estas recomendaciones o no. Lo importante es que tu c√≥digo funcione, adem√°s de ser entendible.

------------------------------------------------------------------------

## Reasignaci√≥n de variables

En **R**, las variables pueden ser reasignadas en cualquier momento simplemente utilizando el operador de asignaci√≥n (`<-` o `=`). Esto significa que una variable puede cambiar su valor o incluso su tipo de datos en tiempo de ejecuci√≥n.

``` r
x <- 10         # Se asigna el valor 10 a 'x'
print(x)        # Muestra: 10

x <- x + 15     # Se reasigna un nuevo valor a 'x'
print(x)        # Muestra: 25
```

R tambi√©n permite **reasignar una variable con un tipo de dato diferente**:

``` r
x <- "Texto"    # Ahora 'x' es un string
print(x)        # Muestra: "Texto"
```

Considera lo siguiente al momento de reasignar variables:

1.  **No es necesario declarar tipos**: R es un lenguaje de tipado din√°mico.
2.  **La reasignaci√≥n sobrescribe el valor anterior**: No hay un historial de cambios a menos que se guarden copias.

### Ejemplo

La canasta familiar b√°sica (conjunto de bienes y servicios que son imprescindibles para satisfacer las necesidades b√°sicas del hogar) en el Ecuador es \$797.69 USD. Esta canasta aumenta aproximadamente \$30.00 USD cada a√±o.

¬øCu√°l ser√° el valor de la canasta familiar b√°sica dentro de 4 a√±os?

> [**Nota 1:**]{.underline} Recuerda utilizar la asignaci√≥n aumentada para resolver el ejemplo.
>
> [**Nota 2:**]{.underline} Recuerda seguir el **enfoque EPS**.

### Soluci√≥n

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

------------------------------------------------------------------------

## Reglas para nombrar variables

En **R** tenemos varias reglas para nombrar variables. Si no se siguen estas reglas, no se crea la variable y obtenemos un error.

1.  Deben comenzar con una letra (A-Z, a-z).

2.  Pueden contener letras (A-Z, a-z), n√∫meros (0-9), guiones bajos (`_`) o puntos (`.`), pero no otros caracteres especiales.

3.  R distingue entre may√∫sculas y min√∫sculas (`Variable` y `variable` son diferentes).

4.  No pueden ser palabras reservadas de R (como `if`, `else`, `function`).

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

------------------------------------------------------------------------

## Palabras reservadas

Las **palabras reservadas** son t√©rminos que tienen un significado especial en el lenguaje y no pueden usarse como nombres de variables, funciones o identificadores. Estas palabras est√°n predefinidas en el lenguaje y sirven para realizar funciones esenciales del sistema, como controlar el flujo del programa, declarar funciones o definir estructuras de datos.

Algunas de las palabras reservadas en **R** son las siguientes:

-   `if`

-   `else`

-   `for`

-   `while`

-   `repeat`

-   `break`

-   `next`

-   `function`

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

------------------------------------------------------------------------

## Comentarios

Los **comentarios** son fragmentos de texto que se a√±aden al c√≥digo para explicar o aclarar su funcionamiento. Los comentarios no afectan la ejecuci√≥n del programa, ya que **R** los ignora completamente. Los comentarios son esenciales para hacer que el c√≥digo sea m√°s **legible** y **comprensible**, especialmente cuando se trabaja en equipo o cuando se necesita mantener el c√≥digo en el futuro.

En **R**, los comentarios se crean usando el s√≠mbolo `#`. Todo lo que siga despu√©s de `#` en una l√≠nea ser√° considerado un comentario.

``` r
# Este es un comentario
x <- 10
```

Los usos recomendados para los comentarios son los siguientes:

-   **Explicar el prop√≥sito del c√≥digo.** Los comentarios ayudan a otros programadores (o a ti mismo en el futuro) a entender lo que hace un bloque de c√≥digo.

``` r
# Calculamos el √°rea de un c√≠rculo usando la f√≥rmula A = pi * r^2
radio <- 5
area <- pi * radio^2
```

-   **"Desactivar" temporalmente partes del c√≥digo.** Los comentarios tambi√©n se usan para "**desactivar"** temporalmente una l√≠nea o bloque de c√≥digo sin eliminarlo.

``` r
# Calculamos el √°rea de un c√≠rculo usando la f√≥rmula A = pi * r^2
radio <- 5
# area <- pi * radio^2
```

-   **Documentar funciones.** En el caso de las funciones, puedes agregar comentarios antes de la declaraci√≥n de la funci√≥n para explicar qu√© hace, qu√© par√°metros recibe y qu√© devuelve.

``` r
# Calcular el √°rea de un c√≠rculo
calcular_area <- function(radio) {
  pi * radio^2
}
```

> Considera que los **comentarios en R** son como **manuales de operaci√≥n** en equipos de ingenier√≠a. Cuando se dise√±an sistemas complejos, se incluyen manuales para que los operadores entiendan c√≥mo funciona la m√°quina y c√≥mo debe ser utilizada. De manera similar, en un c√≥digo, los comentarios sirven para **explicar el prop√≥sito** y el **funcionamiento** de las partes del programa, ayudando a otros programadores (o a uno mismo en el futuro) a comprender mejor el proceso.

### Ejemplo

Comenta el siguiente c√≥digo, aunque antes debes deducir y entender qu√© es lo que est√° haciendo.

``` r
a = 2
b = 4
P = 2 * a + 2 * b
print(P)
```

Adem√°s, ¬øest√°s de acuerdo con los nombres de variables utilizados? Si no est√°s de acuerdo, ¬øcu√°les utilizar√°s t√∫?

### Soluci√≥n

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

------------------------------------------------------------------------

## Mostrar y ocultar el valor de una variable

En **R**, hay diferentes maneras de **mostrar** u **ocultar** el valor de una variable, dependiendo de c√≥mo deseas trabajar con esa variable y de las situaciones en las que necesitas ver su valor durante la ejecuci√≥n del programa.

### Mostrar el valor de una variable

Para **mostrar** el valor de una variable, puedes simplemente escribir el nombre de la variable o usar funciones como `print` para imprimir el valor.

``` r
x <- 10
x           # Esto muestra el valor de 'x'
```

``` r
y <- 5
print(y)    # Imprime el valor de 'y'
```

``` r
x <- 10
x           # Esto muestra el valor de 'x'

y <- 5
print(y)    # Imprime el valor de 'y'
```

En este √∫ltimo ejemplo de c√≥digo se visualiza por pantalla tanto el valor de `x` como el valor de `y`.

### Ocultar el valor de una variable

En **R**, cuando asignas un valor a una variable **no es necesario** "ocultar" expl√≠citamente la visualizaci√≥n de su informaci√≥n dado que **R** lo hace por defecto.

``` r
x <- 10         # El valor se guarda, pero no se imprime
y <- x + 5      # Realiza el c√°lculo sin mostrar el valor
```

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

> **Mostrar** y **ocultar** el valor de una variable en **R** es similar a **verificar los par√°metros** de un sistema en una planta de producci√≥n. Si deseas saber el estado de una m√°quina (mostrar el valor), puedes revisar sus indicadores. Si no te interesa la lectura constante de ciertos valores (ocultar), puedes optar por realizar ajustes sin necesidad de que los resultados se muestren en el monitor todo el tiempo. En programaci√≥n, esto se traduce en mostrar u ocultar el valor de las variables seg√∫n lo necesites para **depuraci√≥n (debugging)**, **optimizaci√≥n** o **simulaciones**.

------------------------------------------------------------------------

## Separar una l√≠nea de c√≥digo en varias l√≠neas

En **R**, puedes **separar una l√≠nea de c√≥digo** en varias l√≠neas sin que se pierda la funcionalidad del c√≥digo. Esto es √∫til para mejorar la **legibilidad** del c√≥digo o cuando las l√≠neas son demasiado largas. **R** tiene reglas que permiten partir las expresiones en partes m√°s manejables, siempre que se sigan algunas pautas.

-   **Las expresiones pueden ser separadas por operadores**: **R** permite dividir una expresi√≥n si el **operador** de la l√≠nea est√° presente al final de la l√≠nea.

-   **Par√©ntesis o corchetes abiertos (`(`, `[`, `{`)**: Si un par√©ntesis o corchete est√° abierto, **R** entiende que la expresi√≥n sigue en la siguiente l√≠nea.

``` r
# Ejemplo 1
# Sin separaci√≥n
resultado <- 10 + 20 + 30 + 40

# Separando en varias l√≠neas
resultado <- 10 + 
             20 + 
             30 + 
             40
```

``` r
# Ejemplo 2
# Sin separaci√≥n
resultado <- sum(10, 20, 30, 40, 50)

# Separando en varias l√≠neas
resultado <- sum(
  10, 
  20, 
  30, 
  40, 
  50
)
```

``` r
# Ejemplo 3
# Sin separaci√≥n
vector <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

# Separando en varias l√≠neas
vector <- c(
  1, 2, 3, 4, 
  5, 6, 7, 8, 
  9, 10
)
```

``` r
# Ejemplo 4
# Sin separaci√≥n
resultado <- mean(c(10, 20, 30, 40, 50)) + sd(c(10, 20, 30, 40, 50))

# Separando en varias l√≠neas
resultado <- mean(
  c(10, 20, 30, 40, 50)
) + sd(
  c(10, 20, 30, 40, 50)
)
```

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

> Separar una l√≠nea de c√≥digo en varias l√≠neas es similar a **dividir un proceso de ensamblaje** en partes m√°s peque√±as y manejables. Imagina que est√°s montando una m√°quina compleja. Si intentas hacerlo todo de una vez, el proceso podr√≠a ser confuso o dif√≠cil de seguir. Pero si divides las tareas en pasos m√°s peque√±os y claros, ser√° mucho m√°s f√°cil de entender, depurar y ajustar. En el c√≥digo, hacer lo mismo con las l√≠neas mejora la **claridad** y facilita futuras modificaciones.

------------------------------------------------------------------------

## Funci√≥n `ls()`

La funci√≥n **`ls()`** en **R** se utiliza para **listar** los objetos presentes en el **espacio de trabajo** de **R**. Estos objetos pueden ser variables, funciones, data frames, matrices, entre otros. Es una herramienta √∫til para explorar el entorno de trabajo y saber qu√© objetos est√°n disponibles en un momento dado.

``` r
# Crear algunos objetos
x <- 10
y <- 20
z <- "Hola mundo"

# Listar los objetos en el espacio de trabajo
ls()  # Devuelve: "x", "y", "z"
```

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

Esta funci√≥n es especialmente √∫til en los siguientes casos:

-   **Explorar el espacio de trabajo**: Al trabajar con muchos objetos, `ls()` te ayuda a verificar r√°pidamente qu√© variables, funciones o datos est√°n disponibles en tu entorno.

-   **Organizar el c√≥digo**: Puedes usar `ls()` al inicio de tu script para verificar qu√© objetos est√°n presentes y garantizar que el espacio de trabajo est√° limpio.

-   **Limpiar el espacio de trabajo (liberar memoria):** A trav√©s de la funci√≥n `rm()`, en conjunto con la funci√≥n `ls()`, se puede limpiar el espacio de trabajo para empezar con un espacio totalmente limpio, sin variables ni informaci√≥n previa que ocupe memoria en la computadora.

> La funci√≥n `ls()` es como **revisar un inventario** de herramientas o materiales en un taller de ingenier√≠a. Imagina que tienes muchas herramientas (como destornilladores, llaves, etc.) y necesitas saber qu√© tienes disponible antes de comenzar un trabajo. La funci√≥n `ls()` te permite ver qu√© herramientas (o, en este caso, objetos) est√°n en tu "taller" (espacio de trabajo) en cualquier momento.

------------------------------------------------------------------------

## Funci√≥n `rm()`

La funci√≥n **`rm()`** en **R** se utiliza para **eliminar** objetos del espacio de trabajo. Esto es √∫til cuando deseas **liberar memoria** o cuando ya no necesitas ciertos objetos, y quieres mantener el entorno de trabajo limpio y organizado.

``` r
# Ejemplo 1
# Crear una variable
x <- 10

# Verificar que 'x' existe
ls()    # Muestra "x"

# Eliminar el objeto 'x'
rm(x)

# Verificar que 'x' ha sido eliminado
ls()    # Ya no muestra "x"
```

``` r
# Ejemplo 2
# Crear m√°s variables
a <- 5
b <- 10
c <- 15

# Verificar los objetos en el entorno
ls()  # Muestra "a", "b", "c"

# Eliminar varios objetos
rm(a, b)

# Verificar que 'a' y 'b' han sido eliminados
ls()  # Muestra solo "c"
```

``` r
# Ejemplo 3
# Crear m√°s variables
x <- 1
y <- 2
z <- 3

# Eliminar todos los objetos del espacio de trabajo
rm(list = ls())

# Verificar que no quedan objetos
ls()    # Devuelve un vector vac√≠o
```

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

Esta funci√≥n es especialmente √∫til en los siguientes casos:

-   **Liberar memoria**: Si trabajas con grandes conjuntos de datos, m√∫ltiples objetos o tu computadora no tiene muchos recursos, puedes usar `rm()` para liberar memoria y evitar que el espacio de trabajo se sature.

-   **Mantener el entorno limpio**: Eliminar objetos que ya no son necesarios te permite mantener el entorno de trabajo organizado y evitar errores causados por variables innecesarias.

-   **Prevenci√≥n de conflictos de nombres**: Al eliminar objetos que podr√≠an estar en conflicto con nuevos objetos o funciones, puedes evitar sobrescribir inadvertidamente nombres importantes.

> La funci√≥n `rm()` en **R** es como **eliminar herramientas o equipos obsoletos de un taller de ingenier√≠a**. Imagina que tienes un taller con muchas herramientas y equipos que ya no usas. Con el tiempo, estos ocupan espacio y pueden generar confusi√≥n. Usar `rm()` ser√≠a como hacer una limpieza y eliminar esas herramientas que ya no necesitas, asegurando que el taller est√© organizado y solo contenga los equipos que son realmente √∫tiles para el trabajo actual.

------------------------------------------------------------------------

## Funciones `save()` y `load()`

Las funciones **`save()`** y **`load()`** en **R** son herramientas √∫tiles para guardar y cargar objetos del espacio de trabajo, lo que permite guardar el progreso de un an√°lisis, o trabajo, y retomarlo m√°s tarde sin perder informaci√≥n. Estas funciones son particularmente √∫tiles cuando trabajas con grandes conjuntos de datos o modelos complejos, ya que te permiten guardar el estado de tu trabajo en archivos y cargarlo posteriormente para continuar desde donde lo dejaste.

### Funci√≥n `save()`

La funci√≥n **`save()`** se utiliza para guardar uno o varios objetos en un archivo. El archivo generado tiene la extensi√≥n `.RData`.

``` r
# Crear algunas variables
x <- 10
y <- 20
z <- 30

# Guardar las variables en un archivo .RData
save(x, y, z, file = "mis_datos.RData")
```

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

### Funci√≥n `load()`

La funci√≥n **`load()`** se utiliza para cargar objetos previamente guardados con `save()` desde un archivo `.RData` al espacio de trabajo actual. Los objetos se restauran con los mismos nombres que ten√≠an cuando se guardaron.

``` r
# Cargar los objetos desde el archivo guardado
load("mis_datos.RData")

# Verificar que los objetos se han cargado
ls()  # Deber√≠as ver "x", "y", "z" de nuevo en el entorno de trabajo
```

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

Estas funciones son especialmente √∫tiles en los siguientes casos:

-   **Guardar el progreso**: Puedes guardar el estado de tu trabajo y retomarlo en otro momento sin tener que volver a ejecutar todo el c√≥digo. Esto es √∫til cuando trabajas con grandes vol√∫menes de datos o modelos computacionalmente costosos.

-   **Compartir datos y resultados**: Puedes guardar objetos y compartir el archivo `.RData` con otros para que carguen y usen los mismos objetos en su entorno de trabajo.

> Las funciones `save()` y `load()` en **R** son como **guardar y recuperar planos de un proyecto de ingenier√≠a**. Imagina que est√°s trabajando en el dise√±o de un edificio y, despu√©s de varias semanas de trabajo, decides guardar todos los planos y documentos en un archivo. M√°s tarde, puedes recuperar esos planos (como un archivo en tu computadora) para continuar donde lo dejaste sin necesidad de rehacer el trabajo. De igual manera, en programaci√≥n, **guardar el estado** de tu trabajo y **cargarlo** cuando sea necesario te permite seguir avanzando de manera eficiente sin perder lo que ya has logrado.

### Ejemplo

Carga la informaci√≥n del archivo `Tema01_Auxiliar_DatosPersonales.RData`. ¬øQu√© personaje es y cu√°les son sus caracter√≠sticas?

[**Nota:**]{.underline} Aseg√∫rate de limpiar el espacio de trabajo antes de cargar la informaci√≥n.

### Soluci√≥n

```{r}
# Ingresa tu c√≥digo aqu√≠ üëΩ
```

------------------------------------------------------------------------
